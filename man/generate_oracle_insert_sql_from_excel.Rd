% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/excel_to_oracle_sql.R
\name{generate_oracle_insert_sql_from_excel}
\alias{generate_oracle_insert_sql_from_excel}
\title{Generate Oracle SQL from an Excel sheet (no DB execution)}
\usage{
generate_oracle_insert_sql_from_excel(
  excel_path,
  sheet,
  table_name,
  out_sql,
  template_path = NULL,
  index_col = NULL,
  index_name = NULL,
  chunk_size = 500L,
  comment = NULL
)
}
\arguments{
\item{excel_path}{Character scalar. Path to the input \code{.xlsx} file.}

\item{sheet}{Sheet name or index to read from \code{excel_path}.}

\item{table_name}{Character scalar. Target Oracle table name (optionally schema-qualified).}

\item{out_sql}{Character scalar. Output path for the generated \code{.sql} file.}

\item{template_path}{Optional character scalar. Path to a Mustache SQL template.
If \code{NULL}, the function looks for \code{inst/templates/insert_all_template.sql}
bundled with this package (via \code{system.file()}).}

\item{index_col}{Optional character scalar. Column name to index. If \code{NULL}, no index is generated.}

\item{index_name}{Optional character scalar. Explicit index name. If missing and
\code{index_col} is provided, a name is auto-generated as
\verb{IX_<TABLE>_<COLUMN>} (non-alphanumerics replaced by \verb{_}).}

\item{chunk_size}{Integer. Number of rows per \verb{INSERT ALL} block. Default \code{500}.}

\item{comment}{Optional character scalar. A comment header injected into the SQL.}
}
\value{
(Invisibly) \code{out_sql} path, after writing the file to disk.
}
\description{
Reads an Excel worksheet and renders an Oracle-compatible \code{.sql} file using a
file-based template (Mustache via \code{{whisker}}). It emits batched
\verb{INSERT /*+ append */ ALL ... SELECT 1 FROM DUAL;} blocks and can optionally
append a \verb{CREATE INDEX} statement.
}
\details{
\strong{Template contract} (Mustache):

The template should reference:
\itemize{
\item \code{{{comment}}}             – a header string
\item \code{{{table}}}               – table name
\item \code{{{col_list}}}            – comma-separated column list
\item iterate \verb{\{\{#rows\}\} ... \{\{/rows\}\}} with each row providing \code{{{values}}}
\item \verb{\{\{#create_index\}\} ... \{\{/create_index\}\}} block with \code{{{index_name}}}, \code{{{index_col}}}
}

Example template (ship in \code{inst/templates/insert_all_template.sql}):

\if{html}{\out{<div class="sourceCode">}}\preformatted{-- \{\{comment\}\}
INSERT /*+ append */ ALL
\{\{#rows\}\}
  INTO \{\{table\}\} (\{\{col_list\}\}) VALUES \{\{values\}\}
\{\{/rows\}\}
SELECT 1 FROM DUAL;
\{\{#create_index\}\}

-- Optional indexing
CREATE INDEX \{\{index_name\}\} ON \{\{table\}\} (\{\{index_col\}\});
\{\{/create_index\}\}
}\if{html}{\out{</div>}}

\strong{Type handling:}
\itemize{
\item \code{NA} → \code{NULL}
\item \code{Date} → \verb{DATE 'YYYY-MM-DD'}
\item \code{POSIXct/POSIXt} → \code{TO_TIMESTAMP('YYYY-MM-DD HH24:MI:SS','YYYY-MM-DD HH24:MI:SS')}
\item numeric → plain number (no scientific notation)
\item logical → \code{1}/\code{0}
\item character → single-quoted with single quotes doubled
}

Columns whose names \emph{look} like dates (e.g., \code{..._date}, \code{datum}, \code{..._dt}) are
lightly coerced from character to \code{Date} when possible.
}
